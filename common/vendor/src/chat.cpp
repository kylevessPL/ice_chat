//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.5
//
// <auto-generated>
//
// Generated from file `chat.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <chat.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 5
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit<::Chat::UsernameAlreadyRegisteredException> iceC_Chat_UsernameAlreadyRegisteredException_init("::Chat::UsernameAlreadyRegisteredException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Chat::RoomNameAlreadyRegisteredException> iceC_Chat_RoomNameAlreadyRegisteredException_init("::Chat::RoomNameAlreadyRegisteredException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Chat::NoRoomFactoryAvailableException> iceC_Chat_NoRoomFactoryAvailableException_init("::Chat::NoRoomFactoryAvailableException");

const ::std::string iceC_Chat_ChatUser_ids[2] =
{
    "::Chat::ChatUser",
    "::Ice::Object"
};
const ::std::string iceC_Chat_ChatUser_ops[] =
{
    "getName",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "sendMessage",
    "sendPrivateMessage"
};
const ::std::string iceC_Chat_ChatUser_sendMessage_name = "sendMessage";
const ::std::string iceC_Chat_ChatUser_getName_name = "getName";
const ::std::string iceC_Chat_ChatUser_sendPrivateMessage_name = "sendPrivateMessage";

const ::std::string iceC_Chat_ChatRoom_ids[2] =
{
    "::Chat::ChatRoom",
    "::Ice::Object"
};
const ::std::string iceC_Chat_ChatRoom_ops[] =
{
    "addUser",
    "getName",
    "getUsers",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "removeUser",
    "sendMessage"
};
const ::std::string iceC_Chat_ChatRoom_sendMessage_name = "sendMessage";
const ::std::string iceC_Chat_ChatRoom_addUser_name = "addUser";
const ::std::string iceC_Chat_ChatRoom_removeUser_name = "removeUser";
const ::std::string iceC_Chat_ChatRoom_getUsers_name = "getUsers";
const ::std::string iceC_Chat_ChatRoom_getName_name = "getName";

const ::std::string iceC_Chat_ChatRoomFactory_ids[2] =
{
    "::Chat::ChatRoomFactory",
    "::Ice::Object"
};
const ::std::string iceC_Chat_ChatRoomFactory_ops[] =
{
    "createChatRoom",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "numOfChatroomsRunning"
};
const ::std::string iceC_Chat_ChatRoomFactory_createChatRoom_name = "createChatRoom";
const ::std::string iceC_Chat_ChatRoomFactory_numOfChatroomsRunning_name = "numOfChatroomsRunning";

const ::std::string iceC_Chat_ChatServer_ids[2] =
{
    "::Chat::ChatServer",
    "::Ice::Object"
};
const ::std::string iceC_Chat_ChatServer_ops[] =
{
    "createChatRoom",
    "getRooms",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "registerChatRoomFactory",
    "registerUser",
    "unregisterChatRoomFactory",
    "unregisterUser"
};
const ::std::string iceC_Chat_ChatServer_registerUser_name = "registerUser";
const ::std::string iceC_Chat_ChatServer_unregisterUser_name = "unregisterUser";
const ::std::string iceC_Chat_ChatServer_getRooms_name = "getRooms";
const ::std::string iceC_Chat_ChatServer_createChatRoom_name = "createChatRoom";
const ::std::string iceC_Chat_ChatServer_registerChatRoomFactory_name = "registerChatRoomFactory";
const ::std::string iceC_Chat_ChatServer_unregisterChatRoomFactory_name = "unregisterChatRoomFactory";

}

Chat::UsernameAlreadyRegisteredException::~UsernameAlreadyRegisteredException()
{
}

const ::std::string&
Chat::UsernameAlreadyRegisteredException::ice_staticId()
{
    static const ::std::string typeId = "::Chat::UsernameAlreadyRegisteredException";
    return typeId;
}

Chat::RoomNameAlreadyRegisteredException::~RoomNameAlreadyRegisteredException()
{
}

const ::std::string&
Chat::RoomNameAlreadyRegisteredException::ice_staticId()
{
    static const ::std::string typeId = "::Chat::RoomNameAlreadyRegisteredException";
    return typeId;
}

Chat::NoRoomFactoryAvailableException::~NoRoomFactoryAvailableException()
{
}

const ::std::string&
Chat::NoRoomFactoryAvailableException::ice_staticId()
{
    static const ::std::string typeId = "::Chat::NoRoomFactoryAvailableException";
    return typeId;
}

bool
Chat::ChatUser::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Chat_ChatUser_ids, iceC_Chat_ChatUser_ids + 2, s);
}

::std::vector<::std::string>
Chat::ChatUser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Chat_ChatUser_ids[0], &iceC_Chat_ChatUser_ids[2]);
}

::std::string
Chat::ChatUser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Chat::ChatUser::ice_staticId()
{
    static const ::std::string typeId = "::Chat::ChatUser";
    return typeId;
}

/// \cond INTERNAL
bool
Chat::ChatUser::_iceD_sendMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ChatUserPrx> iceP_from;
    ::std::string iceP_message;
    istr->readAll(iceP_from, iceP_message);
    inS.endReadParams();
    this->sendMessage(::std::move(iceP_from), ::std::move(iceP_message), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatUser::_iceD_getName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getName(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatUser::_iceD_sendPrivateMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ChatUserPrx> iceP_from;
    ::std::string iceP_message;
    istr->readAll(iceP_from, iceP_message);
    inS.endReadParams();
    this->sendPrivateMessage(::std::move(iceP_from), ::std::move(iceP_message), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatUser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Chat_ChatUser_ops, iceC_Chat_ChatUser_ops + 7, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Chat_ChatUser_ops)
    {
        case 0:
        {
            return _iceD_getName(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_sendMessage(in, current);
        }
        case 6:
        {
            return _iceD_sendPrivateMessage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Chat::ChatRoom::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Chat_ChatRoom_ids, iceC_Chat_ChatRoom_ids + 2, s);
}

::std::vector<::std::string>
Chat::ChatRoom::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Chat_ChatRoom_ids[0], &iceC_Chat_ChatRoom_ids[2]);
}

::std::string
Chat::ChatRoom::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Chat::ChatRoom::ice_staticId()
{
    static const ::std::string typeId = "::Chat::ChatRoom";
    return typeId;
}

/// \cond INTERNAL
bool
Chat::ChatRoom::_iceD_sendMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ChatUserPrx> iceP_from;
    ::std::string iceP_message;
    istr->readAll(iceP_from, iceP_message);
    inS.endReadParams();
    this->sendMessage(::std::move(iceP_from), ::std::move(iceP_message), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatRoom::_iceD_addUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ChatUserPrx> iceP_who;
    istr->readAll(iceP_who);
    inS.endReadParams();
    this->addUser(::std::move(iceP_who), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatRoom::_iceD_removeUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ChatUserPrx> iceP_who;
    istr->readAll(iceP_who);
    inS.endReadParams();
    this->removeUser(::std::move(iceP_who), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatRoom::_iceD_getUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    UserList ret = this->getUsers(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatRoom::_iceD_getName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getName(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatRoom::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Chat_ChatRoom_ops, iceC_Chat_ChatRoom_ops + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Chat_ChatRoom_ops)
    {
        case 0:
        {
            return _iceD_addUser(in, current);
        }
        case 1:
        {
            return _iceD_getName(in, current);
        }
        case 2:
        {
            return _iceD_getUsers(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_removeUser(in, current);
        }
        case 8:
        {
            return _iceD_sendMessage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Chat::ChatRoomFactory::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Chat_ChatRoomFactory_ids, iceC_Chat_ChatRoomFactory_ids + 2, s);
}

::std::vector<::std::string>
Chat::ChatRoomFactory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Chat_ChatRoomFactory_ids[0], &iceC_Chat_ChatRoomFactory_ids[2]);
}

::std::string
Chat::ChatRoomFactory::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Chat::ChatRoomFactory::ice_staticId()
{
    static const ::std::string typeId = "::Chat::ChatRoomFactory";
    return typeId;
}

/// \cond INTERNAL
bool
Chat::ChatRoomFactory::_iceD_createChatRoom(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::shared_ptr<ChatRoomPrx> ret = this->createChatRoom(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatRoomFactory::_iceD_numOfChatroomsRunning(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    int ret = this->numOfChatroomsRunning(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatRoomFactory::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Chat_ChatRoomFactory_ops, iceC_Chat_ChatRoomFactory_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Chat_ChatRoomFactory_ops)
    {
        case 0:
        {
            return _iceD_createChatRoom(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_numOfChatroomsRunning(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Chat::ChatServer::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Chat_ChatServer_ids, iceC_Chat_ChatServer_ids + 2, s);
}

::std::vector<::std::string>
Chat::ChatServer::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Chat_ChatServer_ids[0], &iceC_Chat_ChatServer_ids[2]);
}

::std::string
Chat::ChatServer::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Chat::ChatServer::ice_staticId()
{
    static const ::std::string typeId = "::Chat::ChatServer";
    return typeId;
}

/// \cond INTERNAL
bool
Chat::ChatServer::_iceD_registerUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ChatUserPrx> iceP_who;
    istr->readAll(iceP_who);
    inS.endReadParams();
    this->registerUser(::std::move(iceP_who), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatServer::_iceD_unregisterUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ChatUserPrx> iceP_who;
    istr->readAll(iceP_who);
    inS.endReadParams();
    this->unregisterUser(::std::move(iceP_who), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatServer::_iceD_getRooms(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ChatRoomList ret = this->getRooms(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatServer::_iceD_createChatRoom(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::shared_ptr<ChatRoomPrx> ret = this->createChatRoom(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatServer::_iceD_registerChatRoomFactory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ChatRoomFactoryPrx> iceP_factory;
    istr->readAll(iceP_factory);
    inS.endReadParams();
    this->registerChatRoomFactory(::std::move(iceP_factory), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatServer::_iceD_unregisterChatRoomFactory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<ChatRoomFactoryPrx> iceP_factory;
    istr->readAll(iceP_factory);
    inS.endReadParams();
    this->unregisterChatRoomFactory(::std::move(iceP_factory), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatServer::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Chat_ChatServer_ops, iceC_Chat_ChatServer_ops + 10, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Chat_ChatServer_ops)
    {
        case 0:
        {
            return _iceD_createChatRoom(in, current);
        }
        case 1:
        {
            return _iceD_getRooms(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        case 6:
        {
            return _iceD_registerChatRoomFactory(in, current);
        }
        case 7:
        {
            return _iceD_registerUser(in, current);
        }
        case 8:
        {
            return _iceD_unregisterChatRoomFactory(in, current);
        }
        case 9:
        {
            return _iceD_unregisterUser(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatUserPrx::_iceI_sendMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ChatUserPrx>& iceP_from, const ::std::string& iceP_message, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Chat_ChatUser_sendMessage_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_from, iceP_message);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatUserPrx::_iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Chat_ChatUser_getName_name);
    outAsync->invoke(iceC_Chat_ChatUser_getName_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatUserPrx::_iceI_sendPrivateMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ChatUserPrx>& iceP_from, const ::std::string& iceP_message, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Chat_ChatUser_sendPrivateMessage_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_from, iceP_message);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Chat::ChatUserPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ChatUserPrx>();
}
/// \endcond

const ::std::string&
Chat::ChatUserPrx::ice_staticId()
{
    return ChatUser::ice_staticId();
}

/// \cond INTERNAL
void
Chat::ChatRoomPrx::_iceI_sendMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ChatUserPrx>& iceP_from, const ::std::string& iceP_message, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Chat_ChatRoom_sendMessage_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_from, iceP_message);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatRoomPrx::_iceI_addUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ChatUserPrx>& iceP_who, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Chat_ChatRoom_addUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_who);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatRoomPrx::_iceI_removeUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ChatUserPrx>& iceP_who, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Chat_ChatRoom_removeUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_who);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatRoomPrx::_iceI_getUsers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Chat::UserList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Chat_ChatRoom_getUsers_name);
    outAsync->invoke(iceC_Chat_ChatRoom_getUsers_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatRoomPrx::_iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Chat_ChatRoom_getName_name);
    outAsync->invoke(iceC_Chat_ChatRoom_getName_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Chat::ChatRoomPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ChatRoomPrx>();
}
/// \endcond

const ::std::string&
Chat::ChatRoomPrx::ice_staticId()
{
    return ChatRoom::ice_staticId();
}

/// \cond INTERNAL
void
Chat::ChatRoomFactoryPrx::_iceI_createChatRoom(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Chat::ChatRoomPrx>>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Chat_ChatRoomFactory_createChatRoom_name);
    outAsync->invoke(iceC_Chat_ChatRoomFactory_createChatRoom_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatRoomFactoryPrx::_iceI_numOfChatroomsRunning(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Chat_ChatRoomFactory_numOfChatroomsRunning_name);
    outAsync->invoke(iceC_Chat_ChatRoomFactory_numOfChatroomsRunning_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Chat::ChatRoomFactoryPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ChatRoomFactoryPrx>();
}
/// \endcond

const ::std::string&
Chat::ChatRoomFactoryPrx::ice_staticId()
{
    return ChatRoomFactory::ice_staticId();
}

/// \cond INTERNAL
void
Chat::ChatServerPrx::_iceI_registerUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ChatUserPrx>& iceP_who, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Chat_ChatServer_registerUser_name);
    outAsync->invoke(iceC_Chat_ChatServer_registerUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_who);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const UsernameAlreadyRegisteredException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatServerPrx::_iceI_unregisterUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ChatUserPrx>& iceP_who, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Chat_ChatServer_unregisterUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_who);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatServerPrx::_iceI_getRooms(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Chat::ChatRoomList>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Chat_ChatServer_getRooms_name);
    outAsync->invoke(iceC_Chat_ChatServer_getRooms_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatServerPrx::_iceI_createChatRoom(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Chat::ChatRoomPrx>>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Chat_ChatServer_createChatRoom_name);
    outAsync->invoke(iceC_Chat_ChatServer_createChatRoom_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NoRoomFactoryAvailableException&)
            {
                throw;
            }
            catch(const RoomNameAlreadyRegisteredException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatServerPrx::_iceI_registerChatRoomFactory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ChatRoomFactoryPrx>& iceP_factory, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Chat_ChatServer_registerChatRoomFactory_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_factory);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Chat::ChatServerPrx::_iceI_unregisterChatRoomFactory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<ChatRoomFactoryPrx>& iceP_factory, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Chat_ChatServer_unregisterChatRoomFactory_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_factory);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Chat::ChatServerPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ChatServerPrx>();
}
/// \endcond

const ::std::string&
Chat::ChatServerPrx::ice_staticId()
{
    return ChatServer::ice_staticId();
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Chat_ChatUser_sendMessage_name = "sendMessage";

const ::std::string iceC_Chat_ChatUser_getName_name = "getName";

const ::std::string iceC_Chat_ChatUser_sendPrivateMessage_name = "sendPrivateMessage";

const ::std::string iceC_Chat_ChatRoom_sendMessage_name = "sendMessage";

const ::std::string iceC_Chat_ChatRoom_addUser_name = "addUser";

const ::std::string iceC_Chat_ChatRoom_removeUser_name = "removeUser";

const ::std::string iceC_Chat_ChatRoom_getUsers_name = "getUsers";

const ::std::string iceC_Chat_ChatRoom_getName_name = "getName";

const ::std::string iceC_Chat_ChatRoomFactory_createChatRoom_name = "createChatRoom";

const ::std::string iceC_Chat_ChatRoomFactory_numOfChatroomsRunning_name = "numOfChatroomsRunning";

const ::std::string iceC_Chat_ChatServer_registerUser_name = "registerUser";

const ::std::string iceC_Chat_ChatServer_unregisterUser_name = "unregisterUser";

const ::std::string iceC_Chat_ChatServer_getRooms_name = "getRooms";

const ::std::string iceC_Chat_ChatServer_createChatRoom_name = "createChatRoom";

const ::std::string iceC_Chat_ChatServer_registerChatRoomFactory_name = "registerChatRoomFactory";

const ::std::string iceC_Chat_ChatServer_unregisterChatRoomFactory_name = "unregisterChatRoomFactory";

}

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Chat::UsernameAlreadyRegisteredException> iceC_Chat_UsernameAlreadyRegisteredException_init("::Chat::UsernameAlreadyRegisteredException");

}

Chat::UsernameAlreadyRegisteredException::~UsernameAlreadyRegisteredException() throw()
{
}

::std::string
Chat::UsernameAlreadyRegisteredException::ice_id() const
{
    return "::Chat::UsernameAlreadyRegisteredException";
}

Chat::UsernameAlreadyRegisteredException*
Chat::UsernameAlreadyRegisteredException::ice_clone() const
{
    return new UsernameAlreadyRegisteredException(*this);
}

void
Chat::UsernameAlreadyRegisteredException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Chat::UsernameAlreadyRegisteredException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Chat::UsernameAlreadyRegisteredException", -1, true);
    ::Ice::StreamWriter< UsernameAlreadyRegisteredException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Chat::UsernameAlreadyRegisteredException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< UsernameAlreadyRegisteredException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Chat::RoomNameAlreadyRegisteredException> iceC_Chat_RoomNameAlreadyRegisteredException_init("::Chat::RoomNameAlreadyRegisteredException");

}

Chat::RoomNameAlreadyRegisteredException::~RoomNameAlreadyRegisteredException() throw()
{
}

::std::string
Chat::RoomNameAlreadyRegisteredException::ice_id() const
{
    return "::Chat::RoomNameAlreadyRegisteredException";
}

Chat::RoomNameAlreadyRegisteredException*
Chat::RoomNameAlreadyRegisteredException::ice_clone() const
{
    return new RoomNameAlreadyRegisteredException(*this);
}

void
Chat::RoomNameAlreadyRegisteredException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Chat::RoomNameAlreadyRegisteredException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Chat::RoomNameAlreadyRegisteredException", -1, true);
    ::Ice::StreamWriter< RoomNameAlreadyRegisteredException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Chat::RoomNameAlreadyRegisteredException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< RoomNameAlreadyRegisteredException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Chat::NoRoomFactoryAvailableException> iceC_Chat_NoRoomFactoryAvailableException_init("::Chat::NoRoomFactoryAvailableException");

}

Chat::NoRoomFactoryAvailableException::~NoRoomFactoryAvailableException() throw()
{
}

::std::string
Chat::NoRoomFactoryAvailableException::ice_id() const
{
    return "::Chat::NoRoomFactoryAvailableException";
}

Chat::NoRoomFactoryAvailableException*
Chat::NoRoomFactoryAvailableException::ice_clone() const
{
    return new NoRoomFactoryAvailableException(*this);
}

void
Chat::NoRoomFactoryAvailableException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Chat::NoRoomFactoryAvailableException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Chat::NoRoomFactoryAvailableException", -1, true);
    ::Ice::StreamWriter< NoRoomFactoryAvailableException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Chat::NoRoomFactoryAvailableException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< NoRoomFactoryAvailableException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Chat::upCast(ChatUser* p) { return p; }

void
::IceProxy::Chat::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ChatUser>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ChatUser;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Chat::ChatUser::_iceI_begin_sendMessage(const ::Chat::ChatUserPrx& iceP_from, const ::std::string& iceP_message, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatUser_sendMessage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatUser_sendMessage_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_from);
        ostr->write(iceP_message);
        result->endWriteParams();
        result->invoke(iceC_Chat_ChatUser_sendMessage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Chat::ChatUser::end_sendMessage(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Chat_ChatUser_sendMessage_name);
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatUser::_iceI_begin_getName(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Chat_ChatUser_getName_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatUser_getName_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatUser_getName_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Chat_ChatUser_getName_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::Chat::ChatUser::end_getName(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Chat_ChatUser_getName_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatUser::_iceI_begin_sendPrivateMessage(const ::Chat::ChatUserPrx& iceP_from, const ::std::string& iceP_message, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatUser_sendPrivateMessage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatUser_sendPrivateMessage_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_from);
        ostr->write(iceP_message);
        result->endWriteParams();
        result->invoke(iceC_Chat_ChatUser_sendPrivateMessage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Chat::ChatUser::end_sendPrivateMessage(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Chat_ChatUser_sendPrivateMessage_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Chat::ChatUser::_newInstance() const
{
    return new ChatUser;
}
/// \endcond

const ::std::string&
IceProxy::Chat::ChatUser::ice_staticId()
{
    return ::Chat::ChatUser::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Chat::upCast(ChatRoom* p) { return p; }

void
::IceProxy::Chat::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ChatRoom>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ChatRoom;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoom::_iceI_begin_sendMessage(const ::Chat::ChatUserPrx& iceP_from, const ::std::string& iceP_message, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatRoom_sendMessage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatRoom_sendMessage_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_from);
        ostr->write(iceP_message);
        result->endWriteParams();
        result->invoke(iceC_Chat_ChatRoom_sendMessage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Chat::ChatRoom::end_sendMessage(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Chat_ChatRoom_sendMessage_name);
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoom::_iceI_begin_addUser(const ::Chat::ChatUserPrx& iceP_who, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatRoom_addUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatRoom_addUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_who);
        result->endWriteParams();
        result->invoke(iceC_Chat_ChatRoom_addUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Chat::ChatRoom::end_addUser(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Chat_ChatRoom_addUser_name);
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoom::_iceI_begin_removeUser(const ::Chat::ChatUserPrx& iceP_who, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatRoom_removeUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatRoom_removeUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_who);
        result->endWriteParams();
        result->invoke(iceC_Chat_ChatRoom_removeUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Chat::ChatRoom::end_removeUser(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Chat_ChatRoom_removeUser_name);
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoom::_iceI_begin_getUsers(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Chat_ChatRoom_getUsers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatRoom_getUsers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatRoom_getUsers_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Chat_ChatRoom_getUsers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Chat::UserList
IceProxy::Chat::ChatRoom::end_getUsers(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Chat_ChatRoom_getUsers_name);
    ::Chat::UserList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoom::_iceI_begin_getName(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Chat_ChatRoom_getName_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatRoom_getName_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatRoom_getName_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Chat_ChatRoom_getName_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::Chat::ChatRoom::end_getName(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Chat_ChatRoom_getName_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Chat::ChatRoom::_newInstance() const
{
    return new ChatRoom;
}
/// \endcond

const ::std::string&
IceProxy::Chat::ChatRoom::ice_staticId()
{
    return ::Chat::ChatRoom::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Chat::upCast(ChatRoomFactory* p) { return p; }

void
::IceProxy::Chat::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ChatRoomFactory>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ChatRoomFactory;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoomFactory::_iceI_begin_createChatRoom(const ::std::string& iceP_name, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Chat_ChatRoomFactory_createChatRoom_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatRoomFactory_createChatRoom_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatRoomFactory_createChatRoom_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        result->endWriteParams();
        result->invoke(iceC_Chat_ChatRoomFactory_createChatRoom_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Chat::ChatRoomPrx
IceProxy::Chat::ChatRoomFactory::end_createChatRoom(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Chat_ChatRoomFactory_createChatRoom_name);
    ::Chat::ChatRoomPrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoomFactory::_iceI_begin_numOfChatroomsRunning(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Chat_ChatRoomFactory_numOfChatroomsRunning_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatRoomFactory_numOfChatroomsRunning_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatRoomFactory_numOfChatroomsRunning_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Chat_ChatRoomFactory_numOfChatroomsRunning_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Chat::ChatRoomFactory::end_numOfChatroomsRunning(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Chat_ChatRoomFactory_numOfChatroomsRunning_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Chat::ChatRoomFactory::_newInstance() const
{
    return new ChatRoomFactory;
}
/// \endcond

const ::std::string&
IceProxy::Chat::ChatRoomFactory::ice_staticId()
{
    return ::Chat::ChatRoomFactory::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Chat::upCast(ChatServer* p) { return p; }

void
::IceProxy::Chat::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ChatServer>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ChatServer;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::_iceI_begin_registerUser(const ::Chat::ChatUserPrx& iceP_who, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Chat_ChatServer_registerUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatServer_registerUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatServer_registerUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_who);
        result->endWriteParams();
        result->invoke(iceC_Chat_ChatServer_registerUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Chat::ChatServer::end_registerUser(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Chat_ChatServer_registerUser_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Chat::UsernameAlreadyRegisteredException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::_iceI_begin_unregisterUser(const ::Chat::ChatUserPrx& iceP_who, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatServer_unregisterUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatServer_unregisterUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_who);
        result->endWriteParams();
        result->invoke(iceC_Chat_ChatServer_unregisterUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Chat::ChatServer::end_unregisterUser(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Chat_ChatServer_unregisterUser_name);
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::_iceI_begin_getRooms(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Chat_ChatServer_getRooms_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatServer_getRooms_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatServer_getRooms_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Chat_ChatServer_getRooms_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Chat::ChatRoomList
IceProxy::Chat::ChatServer::end_getRooms(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Chat_ChatServer_getRooms_name);
    ::Chat::ChatRoomList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::_iceI_begin_createChatRoom(const ::std::string& iceP_name, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Chat_ChatServer_createChatRoom_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatServer_createChatRoom_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatServer_createChatRoom_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        result->endWriteParams();
        result->invoke(iceC_Chat_ChatServer_createChatRoom_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Chat::ChatRoomPrx
IceProxy::Chat::ChatServer::end_createChatRoom(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Chat_ChatServer_createChatRoom_name);
    ::Chat::ChatRoomPrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Chat::NoRoomFactoryAvailableException&)
        {
            throw;
        }
        catch(const ::Chat::RoomNameAlreadyRegisteredException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::_iceI_begin_registerChatRoomFactory(const ::Chat::ChatRoomFactoryPrx& iceP_factory, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatServer_registerChatRoomFactory_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatServer_registerChatRoomFactory_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_factory);
        result->endWriteParams();
        result->invoke(iceC_Chat_ChatServer_registerChatRoomFactory_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Chat::ChatServer::end_registerChatRoomFactory(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Chat_ChatServer_registerChatRoomFactory_name);
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::_iceI_begin_unregisterChatRoomFactory(const ::Chat::ChatRoomFactoryPrx& iceP_factory, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Chat_ChatServer_unregisterChatRoomFactory_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Chat_ChatServer_unregisterChatRoomFactory_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_factory);
        result->endWriteParams();
        result->invoke(iceC_Chat_ChatServer_unregisterChatRoomFactory_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Chat::ChatServer::end_unregisterChatRoomFactory(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Chat_ChatServer_unregisterChatRoomFactory_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Chat::ChatServer::_newInstance() const
{
    return new ChatServer;
}
/// \endcond

const ::std::string&
IceProxy::Chat::ChatServer::ice_staticId()
{
    return ::Chat::ChatServer::ice_staticId();
}

Chat::ChatUser::~ChatUser()
{
}

/// \cond INTERNAL
::Ice::Object* Chat::upCast(ChatUser* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Chat_ChatUser_ids[2] =
{
    "::Chat::ChatUser",
    "::Ice::Object"
};

}

bool
Chat::ChatUser::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Chat_ChatUser_ids, iceC_Chat_ChatUser_ids + 2, s);
}

::std::vector< ::std::string>
Chat::ChatUser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Chat_ChatUser_ids[0], &iceC_Chat_ChatUser_ids[2]);
}

const ::std::string&
Chat::ChatUser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Chat::ChatUser::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Chat::ChatUser";
    return typeId;
#else
    return iceC_Chat_ChatUser_ids[0];
#endif
}

/// \cond INTERNAL
bool
Chat::ChatUser::_iceD_sendMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ChatUserPrx iceP_from;
    ::std::string iceP_message;
    istr->read(iceP_from);
    istr->read(iceP_message);
    inS.endReadParams();
    this->sendMessage(iceP_from, iceP_message, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatUser::_iceD_getName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getName(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatUser::_iceD_sendPrivateMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ChatUserPrx iceP_from;
    ::std::string iceP_message;
    istr->read(iceP_from);
    istr->read(iceP_message);
    inS.endReadParams();
    this->sendPrivateMessage(iceP_from, iceP_message, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Chat_ChatUser_all[] =
{
    "getName",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "sendMessage",
    "sendPrivateMessage"
};

}

/// \cond INTERNAL
bool
Chat::ChatUser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Chat_ChatUser_all, iceC_Chat_ChatUser_all + 7, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Chat_ChatUser_all)
    {
        case 0:
        {
            return _iceD_getName(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_sendMessage(in, current);
        }
        case 6:
        {
            return _iceD_sendPrivateMessage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Chat::ChatUser::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ChatUser, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Chat::ChatUser::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ChatUser, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Chat::_icePatchObjectPtr(ChatUserPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ChatUserPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ChatUser::ice_staticId(), v);
    }
}
/// \endcond

Chat::ChatRoom::~ChatRoom()
{
}

/// \cond INTERNAL
::Ice::Object* Chat::upCast(ChatRoom* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Chat_ChatRoom_ids[2] =
{
    "::Chat::ChatRoom",
    "::Ice::Object"
};

}

bool
Chat::ChatRoom::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Chat_ChatRoom_ids, iceC_Chat_ChatRoom_ids + 2, s);
}

::std::vector< ::std::string>
Chat::ChatRoom::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Chat_ChatRoom_ids[0], &iceC_Chat_ChatRoom_ids[2]);
}

const ::std::string&
Chat::ChatRoom::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Chat::ChatRoom::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Chat::ChatRoom";
    return typeId;
#else
    return iceC_Chat_ChatRoom_ids[0];
#endif
}

/// \cond INTERNAL
bool
Chat::ChatRoom::_iceD_sendMessage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ChatUserPrx iceP_from;
    ::std::string iceP_message;
    istr->read(iceP_from);
    istr->read(iceP_message);
    inS.endReadParams();
    this->sendMessage(iceP_from, iceP_message, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatRoom::_iceD_addUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ChatUserPrx iceP_who;
    istr->read(iceP_who);
    inS.endReadParams();
    this->addUser(iceP_who, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatRoom::_iceD_removeUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ChatUserPrx iceP_who;
    istr->read(iceP_who);
    inS.endReadParams();
    this->removeUser(iceP_who, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatRoom::_iceD_getUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    UserList ret = this->getUsers(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatRoom::_iceD_getName(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getName(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Chat_ChatRoom_all[] =
{
    "addUser",
    "getName",
    "getUsers",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "removeUser",
    "sendMessage"
};

}

/// \cond INTERNAL
bool
Chat::ChatRoom::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Chat_ChatRoom_all, iceC_Chat_ChatRoom_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Chat_ChatRoom_all)
    {
        case 0:
        {
            return _iceD_addUser(in, current);
        }
        case 1:
        {
            return _iceD_getName(in, current);
        }
        case 2:
        {
            return _iceD_getUsers(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_removeUser(in, current);
        }
        case 8:
        {
            return _iceD_sendMessage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Chat::ChatRoom::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ChatRoom, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Chat::ChatRoom::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ChatRoom, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Chat::_icePatchObjectPtr(ChatRoomPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ChatRoomPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ChatRoom::ice_staticId(), v);
    }
}
/// \endcond

Chat::ChatRoomFactory::~ChatRoomFactory()
{
}

/// \cond INTERNAL
::Ice::Object* Chat::upCast(ChatRoomFactory* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Chat_ChatRoomFactory_ids[2] =
{
    "::Chat::ChatRoomFactory",
    "::Ice::Object"
};

}

bool
Chat::ChatRoomFactory::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Chat_ChatRoomFactory_ids, iceC_Chat_ChatRoomFactory_ids + 2, s);
}

::std::vector< ::std::string>
Chat::ChatRoomFactory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Chat_ChatRoomFactory_ids[0], &iceC_Chat_ChatRoomFactory_ids[2]);
}

const ::std::string&
Chat::ChatRoomFactory::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Chat::ChatRoomFactory::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Chat::ChatRoomFactory";
    return typeId;
#else
    return iceC_Chat_ChatRoomFactory_ids[0];
#endif
}

/// \cond INTERNAL
bool
Chat::ChatRoomFactory::_iceD_createChatRoom(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->read(iceP_name);
    inS.endReadParams();
    ChatRoomPrx ret = this->createChatRoom(iceP_name, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatRoomFactory::_iceD_numOfChatroomsRunning(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Int ret = this->numOfChatroomsRunning(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Chat_ChatRoomFactory_all[] =
{
    "createChatRoom",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "numOfChatroomsRunning"
};

}

/// \cond INTERNAL
bool
Chat::ChatRoomFactory::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Chat_ChatRoomFactory_all, iceC_Chat_ChatRoomFactory_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Chat_ChatRoomFactory_all)
    {
        case 0:
        {
            return _iceD_createChatRoom(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_numOfChatroomsRunning(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Chat::ChatRoomFactory::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ChatRoomFactory, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Chat::ChatRoomFactory::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ChatRoomFactory, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Chat::_icePatchObjectPtr(ChatRoomFactoryPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ChatRoomFactoryPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ChatRoomFactory::ice_staticId(), v);
    }
}
/// \endcond

Chat::ChatServer::~ChatServer()
{
}

/// \cond INTERNAL
::Ice::Object* Chat::upCast(ChatServer* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Chat_ChatServer_ids[2] =
{
    "::Chat::ChatServer",
    "::Ice::Object"
};

}

bool
Chat::ChatServer::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Chat_ChatServer_ids, iceC_Chat_ChatServer_ids + 2, s);
}

::std::vector< ::std::string>
Chat::ChatServer::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Chat_ChatServer_ids[0], &iceC_Chat_ChatServer_ids[2]);
}

const ::std::string&
Chat::ChatServer::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Chat::ChatServer::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Chat::ChatServer";
    return typeId;
#else
    return iceC_Chat_ChatServer_ids[0];
#endif
}

/// \cond INTERNAL
bool
Chat::ChatServer::_iceD_registerUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ChatUserPrx iceP_who;
    istr->read(iceP_who);
    inS.endReadParams();
    this->registerUser(iceP_who, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatServer::_iceD_unregisterUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ChatUserPrx iceP_who;
    istr->read(iceP_who);
    inS.endReadParams();
    this->unregisterUser(iceP_who, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatServer::_iceD_getRooms(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ChatRoomList ret = this->getRooms(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatServer::_iceD_createChatRoom(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->read(iceP_name);
    inS.endReadParams();
    ChatRoomPrx ret = this->createChatRoom(iceP_name, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatServer::_iceD_registerChatRoomFactory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ChatRoomFactoryPrx iceP_factory;
    istr->read(iceP_factory);
    inS.endReadParams();
    this->registerChatRoomFactory(iceP_factory, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Chat::ChatServer::_iceD_unregisterChatRoomFactory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ChatRoomFactoryPrx iceP_factory;
    istr->read(iceP_factory);
    inS.endReadParams();
    this->unregisterChatRoomFactory(iceP_factory, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Chat_ChatServer_all[] =
{
    "createChatRoom",
    "getRooms",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "registerChatRoomFactory",
    "registerUser",
    "unregisterChatRoomFactory",
    "unregisterUser"
};

}

/// \cond INTERNAL
bool
Chat::ChatServer::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Chat_ChatServer_all, iceC_Chat_ChatServer_all + 10, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Chat_ChatServer_all)
    {
        case 0:
        {
            return _iceD_createChatRoom(in, current);
        }
        case 1:
        {
            return _iceD_getRooms(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        case 6:
        {
            return _iceD_registerChatRoomFactory(in, current);
        }
        case 7:
        {
            return _iceD_registerUser(in, current);
        }
        case 8:
        {
            return _iceD_unregisterChatRoomFactory(in, current);
        }
        case 9:
        {
            return _iceD_unregisterUser(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Chat::ChatServer::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ChatServer, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Chat::ChatServer::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ChatServer, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Chat::_icePatchObjectPtr(ChatServerPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ChatServerPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ChatServer::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
